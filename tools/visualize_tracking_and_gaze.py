import os
import os.path as osp
import tempfile
from argparse import ArgumentParser
import json
import pandas as pd
import numpy as np

import mmcv

from qdtrack.apis import inference_model, init_model

from qdtrack.core import imshow_tracks, restore_result

# Generated by chat-GPT
import math
def point_distance_to_rectangle(point, bbox):
    """
    Checks whether a point is inside a rectangle and calculates the Euclidean distance
    to the nearest point inside the rectangle if the point is outside.

    Args:
        point (tuple): Tuple containing the x and y coordinates of the point.
        rectangle (tuple): Tuple containing the top left and bottom right corners of the rectangle.

    Returns:
        tuple: A tuple containing a boolean indicating whether the point is inside the rectangle,
               and the Euclidean distance to the nearest point inside the rectangle if applicable.
    """
    x, y = point
    x1, y1 = bbox[0], bbox[1]
    x2, y2 = bbox[2], bbox[3]

    if x1 <= x <= x2 and y1 <= y <= y2:
        return 0.0
    else:
        nearest_x = max(x1, min(x, x2))
        nearest_y = max(y1, min(y, y2))
        distance = math.sqrt((x - nearest_x)**2 + (y - nearest_y)**2)
        return distance
    

def main():
    parser = ArgumentParser()
    parser.add_argument('--config', help='config file', 
                        default='configs/aegis/qdtrack-frcnn_r50_fpn_12e_aegis.py')
    parser.add_argument(
        '--device', default='cuda:0', help='device used for inference')
    parser.add_argument('--checkpoint', help='checkpoint file', 
                        default='/srv/beegfs02/scratch/aegis_cvl/data/nikola/code/qdtrack-frcnn_r50_fpn_12e_bdd100k-13328aed.pth')
    parser.add_argument('--recording_dir',
                        default='/srv/beegfs02/scratch/aegis_cvl/data/nikola/aegis_rides/2023-07-04_15-15-04-fdf08a6e')
    parser.add_argument(
        '--score-thr',
        type=float,
        default=0.0,
        help='The threshold of score to filter bboxes.')
    parser.add_argument(
        '--show',
        action='store_true',
        help='whether show the results on the fly')
    parser.add_argument(
        '--backend',
        choices=['cv2', 'plt'],
        default='cv2',
        help='the backend to visualize the results')
    parser.add_argument('--fps', help='FPS of the output video', default=30)
    args = parser.parse_args()

    radius_tres = 60.0

    video_path = os.path.join(args.recording_dir, '1bf99e7a_0.0-133.421.mp4')
    gaze_path = os.path.join(args.recording_dir, 'world_gaze.csv') 
    tracking_path = os.path.join(args.recording_dir, 'track_results.json')
    output_path = os.path.join(args.recording_dir, 'awareness_map.mp4')

    with open(tracking_path, 'r') as fh:
        tracking_res = json.load(fh)
    for i, _ in enumerate(tracking_res):
        for j, _ in enumerate(tracking_res[i]):
            if tracking_res[i][j] == []:
                tracking_res[i][j] = np.empty((0, 6)).astype(np.float64)
            else:
                tracking_res[i][j] = np.asarray(tracking_res[i][j]).astype(np.float64)

    gaze_xy = pd.read_csv(gaze_path)[['gaze x [px]', 'gaze y [px]']].values

    # load images
    if osp.isdir(video_path):
        imgs = sorted(
            filter(lambda x: x.endswith(('.jpg', '.png', '.jpeg')),
                   os.listdir(video_path)),
            key=lambda x: int(x.split('.')[0][-7:]))  # may cause bug
        IN_VIDEO = False
    else:
        imgs = mmcv.VideoReader(video_path)
        IN_VIDEO = True
        
    # define output
    if output_path is not None:
        if output_path.endswith('.mp4'):
            OUT_VIDEO = True
            out_dir = tempfile.TemporaryDirectory()
            out_path = out_dir.name
            _out = output_path.rsplit(os.sep, 1)
            if len(_out) > 1:
                os.makedirs(_out[0], exist_ok=True)
        else:
            OUT_VIDEO = False
            out_path = output_path
            os.makedirs(out_path, exist_ok=True)

    fps = args.fps
    if args.show or OUT_VIDEO:
        if fps is None and IN_VIDEO:
            fps = imgs.fps
        if not fps:
            raise ValueError('Please set the FPS for the output video.')
        fps = int(fps)

    # build the model from a config file and a checkpoint file
    model = init_model(args.config, args.checkpoint, device=args.device)

    prog_bar = mmcv.ProgressBar(len(imgs))
    awareness_map = {}
    # test and show/save the image
    for i, img in enumerate(imgs):
        if isinstance(img, str):
            img = osp.join(video_path, img)

        gaze_xy_i = gaze_xy[i]
        tracking_res_i = tracking_res[i]

        bboxes_i, labels_i, ids_i = restore_result(tracking_res_i, return_ids=True)

        for bbox_ij, label_ij, id_ij in zip(bboxes_i, labels_i, ids_i):
            # Check does gaze fall near the box
            if id_ij not in awareness_map:
                awareness_map[id_ij] = {'class': label_ij, 'gazed': 0.0}
  
            dist_ij = point_distance_to_rectangle(gaze_xy_i, bbox_ij)
            if dist_ij < radius_tres:
                awareness_map[id_ij]['gazed'] += 1.0

        result = {}
        result['track_results'] = tracking_res_i

        if output_path is not None:
            if IN_VIDEO or OUT_VIDEO:
                out_file = osp.join(out_path, f'{i:06d}.jpg')
            else:
                out_file = osp.join(out_path, img.rsplit(os.sep, 1)[-1])
        else:
            out_file = None
        model.show_result(
            img,
            result,
            score_thr=args.score_thr,
            show=args.show,
            wait_time=int(1000. / fps) if fps else 0,
            out_file=out_file,
            backend=args.backend,
            gaze_xy=gaze_xy_i,
            awareness_map=awareness_map,
            radius_tres=radius_tres,
            )
        prog_bar.update()

    if output_path and OUT_VIDEO:
        print(f'making the output video at {output_path} with a FPS of {fps}')
        mmcv.frames2video(out_path, output_path, fps=fps, fourcc='mp4v')
        out_dir.cleanup()

if __name__ == '__main__':
    main()
